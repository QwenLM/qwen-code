/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import * as vscode from 'vscode';
import { activate } from './extension.js';
import {
  IDE_DEFINITIONS,
  detectIdeFromEnv,
} from '@qwen-code/qwen-code-core/src/ide/detect-ide.js';

vi.mock('@qwen-code/qwen-code-core/src/ide/detect-ide.js', async () => {
  const actual = await vi.importActual(
    '@qwen-code/qwen-code-core/src/ide/detect-ide.js',
  );
  return {
    ...actual,
    detectIdeFromEnv: vi.fn(() => IDE_DEFINITIONS.vscode),
  };
});

vi.mock('vscode', () => ({
  window: {
    createOutputChannel: vi.fn(() => ({
      appendLine: vi.fn(),
      dispose: vi.fn(),
    })),
    showInformationMessage: vi.fn(),
    createTerminal: vi.fn(() => ({
      show: vi.fn(),
      sendText: vi.fn(),
    })),
    onDidChangeActiveTextEditor: vi.fn(),
    activeTextEditor: undefined,
    tabGroups: {
      all: [],
      close: vi.fn(),
    },
    showTextDocument: vi.fn(),
    showWorkspaceFolderPick: vi.fn(),
  },
  workspace: {
    workspaceFolders: [],
    onDidCloseTextDocument: vi.fn(),
    registerTextDocumentContentProvider: vi.fn(),
    onDidChangeWorkspaceFolders: vi.fn(),
    onDidGrantWorkspaceTrust: vi.fn(),
  },
  commands: {
    registerCommand: vi.fn(),
    executeCommand: vi.fn(),
  },
  Uri: {
    joinPath: vi.fn(),
    parse: vi.fn((uri) => ({
      toString: vi.fn(() => uri),
      scheme: 'qwen-diff',
    })),
  },
  ExtensionMode: {
    Development: 1,
    Production: 2,
  },
  EventEmitter: vi.fn(() => ({
    event: vi.fn(),
    fire: vi.fn(),
    dispose: vi.fn(),
  })),
  extensions: {
    getExtension: vi.fn(),
  },
}));

describe('activate', () => {
  let context: vscode.ExtensionContext;

  beforeEach(() => {
    vi.mocked(vscode.window.showInformationMessage).mockResolvedValue(
      undefined,
    );
    context = {
      subscriptions: [],
      environmentVariableCollection: {
        replace: vi.fn(),
      },
      globalState: {
        get: vi.fn(),
        update: vi.fn(),
      },
      extensionUri: {
        fsPath: '/path/to/extension',
      },
      extension: {
        packageJSON: {
          version: '1.1.0',
        },
      },
    } as unknown as vscode.ExtensionContext;
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should show the info message on first activation', async () => {
    const showInformationMessageMock = vi
      .mocked(vscode.window.showInformationMessage)
      .mockResolvedValue(undefined as never);
    vi.mocked(context.globalState.get).mockReturnValue(undefined);
    vi.mocked(vscode.extensions.getExtension).mockReturnValue({
      packageJSON: { version: '1.1.0' },
    } as vscode.Extension<unknown>);
    await activate(context);
    expect(showInformationMessageMock).toHaveBeenCalledWith(
      'Qwen Code Companion extension successfully installed.',
    );
  });

  it('should not show the info message on subsequent activations', async () => {
    vi.mocked(context.globalState.get).mockReturnValue(true);
    vi.mocked(vscode.extensions.getExtension).mockReturnValue({
      packageJSON: { version: '1.1.0' },
    } as vscode.Extension<unknown>);
    await activate(context);
    expect(vscode.window.showInformationMessage).not.toHaveBeenCalled();
  });

  it('should register a handler for onDidGrantWorkspaceTrust', async () => {
    await activate(context);
    expect(vscode.workspace.onDidGrantWorkspaceTrust).toHaveBeenCalled();
  });

  it('should launch the Qwen Code when the user clicks the button', async () => {
    const showInformationMessageMock = vi
      .mocked(vscode.window.showInformationMessage)
      .mockResolvedValue('Run Qwen Code' as never);
    vi.mocked(context.globalState.get).mockReturnValue(undefined);
    vi.mocked(vscode.extensions.getExtension).mockReturnValue({
      packageJSON: { version: '1.1.0' },
    } as vscode.Extension<unknown>);
    await activate(context);
    expect(showInformationMessageMock).toHaveBeenCalledWith(
      'Qwen Code Companion extension successfully installed.',
    );
  });

  describe('update notification', () => {
    beforeEach(() => {
      // Prevent the "installed" message from showing
      vi.mocked(context.globalState.get).mockReturnValue(true);
    });

    it('should show an update notification if a newer version is available', async () => {
      vi.spyOn(global, 'fetch').mockResolvedValue({
        ok: true,
        json: async () => ({
          results: [
            {
              extensions: [
                {
                  versions: [{ version: '1.2.0' }],
                },
              ],
            },
          ],
        }),
      } as Response);

      const showInformationMessageMock = vi.mocked(
        vscode.window.showInformationMessage,
      );

      await activate(context);

      expect(showInformationMessageMock).toHaveBeenCalledWith(
        'A new version (1.2.0) of the Qwen Code Companion extension is available.',
        'Update to latest version',
      );
    });

    it('should not show an update notification if the version is the same', async () => {
      vi.spyOn(global, 'fetch').mockResolvedValue({
        ok: true,
        json: async () => ({
          results: [
            {
              extensions: [
                {
                  versions: [{ version: '1.1.0' }],
                },
              ],
            },
          ],
        }),
      } as Response);

      const showInformationMessageMock = vi.mocked(
        vscode.window.showInformationMessage,
      );

      await activate(context);

      expect(showInformationMessageMock).not.toHaveBeenCalled();
    });

    it.each([
      {
        ide: IDE_DEFINITIONS.cloudshell,
      },
      { ide: IDE_DEFINITIONS.firebasestudio },
    ])('does not show the notification for $ide.name', async ({ ide }) => {
      vi.mocked(detectIdeFromEnv).mockReturnValue(ide);
      vi.mocked(context.globalState.get).mockReturnValue(undefined);
      const showInformationMessageMock = vi.mocked(
        vscode.window.showInformationMessage,
      );

      await activate(context);

      expect(showInformationMessageMock).not.toHaveBeenCalled();
    });

    it('should not show an update notification if the version is older', async () => {
      vi.spyOn(global, 'fetch').mockResolvedValue({
        ok: true,
        json: async () => ({
          results: [
            {
              extensions: [
                {
                  versions: [{ version: '1.0.0' }],
                },
              ],
            },
          ],
        }),
      } as Response);

      const showInformationMessageMock = vi.mocked(
        vscode.window.showInformationMessage,
      );

      await activate(context);

      expect(showInformationMessageMock).not.toHaveBeenCalled();
    });

    it('should execute the install command when the user clicks "Update"', async () => {
      vi.spyOn(global, 'fetch').mockResolvedValue({
        ok: true,
        json: async () => ({
          results: [
            {
              extensions: [
                {
                  versions: [{ version: '1.2.0' }],
                },
              ],
            },
          ],
        }),
      } as Response);
      vi.mocked(vscode.window.showInformationMessage).mockResolvedValue(
        'Update to latest version' as never,
      );
      const executeCommandMock = vi.mocked(vscode.commands.executeCommand);

      await activate(context);

      // Wait for the promise from showInformationMessage.then() to resolve
      await new Promise(process.nextTick);

      expect(executeCommandMock).toHaveBeenCalledWith(
        'workbench.extensions.installExtension',
        'qwenlm.qwen-code-vscode-ide-companion',
      );
    });

    it('should handle fetch errors gracefully', async () => {
      vi.spyOn(global, 'fetch').mockResolvedValue({
        ok: false,
        statusText: 'Internal Server Error',
      } as Response);

      const showInformationMessageMock = vi.mocked(
        vscode.window.showInformationMessage,
      );

      await activate(context);

      expect(showInformationMessageMock).not.toHaveBeenCalled();
    });
  });
});

describe('extension commands', () => {
  let context: vscode.ExtensionContext;

  beforeEach(() => {
    vi.mocked(vscode.window.showInformationMessage).mockResolvedValue(
      undefined,
    );
    context = {
      subscriptions: [],
      environmentVariableCollection: {
        replace: vi.fn(),
      },
      globalState: {
        get: vi.fn(),
        update: vi.fn(),
      },
      extensionUri: {
        fsPath: '/path/to/extension',
        toString: () => 'file:///path/to/extension',
      },
      extension: {
        packageJSON: {
          version: '1.1.0',
        },
      },
    } as unknown as vscode.ExtensionContext;
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should run qwen code command when workspace folder exists', async () => {
    const mockWorkspaceFolders = [
      {
        uri: {
          fsPath: '/test/workspace',
          scheme: 'file',
          authority: '',
          path: '/test/workspace',
          query: '',
          fragment: '',
          toString: vi.fn(() => '/test/workspace'),
          toJSON: vi.fn(() => ({ fsPath: '/test/workspace' })),
        },
        name: 'test-workspace',
        index: 0,
      } as any, // eslint-disable-line @typescript-eslint/no-explicit-any // eslint-disable-line @typescript-eslint/no-explicit-any
    ] as any; // eslint-disable-line @typescript-eslint/no-explicit-any
    vi.mocked(vscode.workspace).workspaceFolders = mockWorkspaceFolders;
    vi.mocked(vscode.window.createTerminal).mockReturnValue({
      show: vi.fn(),
      sendText: vi.fn(),
    } as any); // eslint-disable-line @typescript-eslint/no-explicit-any

    await activate(context);

    // Get the registered command for qwen-code.runQwenCode
    const runQwenCodeCommand = vi.mocked(vscode.commands.registerCommand)
      .mock.calls
      .find(call => call[0] === 'qwen-code.runQwenCode')?.[1];

    if (runQwenCodeCommand) {
      await runQwenCodeCommand();
      
      expect(vscode.window.createTerminal).toHaveBeenCalledWith({
        name: 'Qwen Code (test-workspace)',
        cwd: '/test/workspace',
      });
      expect(vscode.window.createTerminal().show).toHaveBeenCalled();
      expect(vscode.window.createTerminal().sendText).toHaveBeenCalledWith('qwen');
    }
  });

  it('should show message when no folder is open for qwen-code.runQwenCode', async () => {
    vi.mocked(vscode.workspace).workspaceFolders = undefined;
    const showInfoMessageSpy = vi.mocked(vscode.window.showInformationMessage);

    await activate(context);

    // Get the registered command for qwen-code.runQwenCode
    const runQwenCodeCommand = vi.mocked(vscode.commands.registerCommand)
      .mock.calls
      .find(call => call[0] === 'qwen-code.runQwenCode')?.[1];

    if (runQwenCodeCommand) {
      await runQwenCodeCommand();
      
      expect(showInfoMessageSpy).toHaveBeenCalledWith(
        'No folder open. Please open a folder to run Qwen Code.'
      );
    }
  });

  it('should handle multiple workspace folders for qwen-code.runQwenCode', async () => {
    const mockWorkspaceFolders = [
      {
        uri: {
          fsPath: '/test/workspace1',
          scheme: 'file',
          authority: '',
          path: '/test/workspace1',
          query: '',
          fragment: '',
          toString: vi.fn(() => '/test/workspace1'),
          toJSON: vi.fn(() => ({ fsPath: '/test/workspace1' })),
        },
        name: 'workspace1',
        index: 0,
      } as any, // eslint-disable-line @typescript-eslint/no-explicit-any
      {
        uri: {
          fsPath: '/test/workspace2',
          scheme: 'file',
          authority: '',
          path: '/test/workspace2',
          query: '',
          fragment: '',
          toString: vi.fn(() => '/test/workspace2'),
          toJSON: vi.fn(() => ({ fsPath: '/test/workspace2' })),
        },
        name: 'workspace2',
        index: 1,
      } as any, // eslint-disable-line @typescript-eslint/no-explicit-any // eslint-disable-line @typescript-eslint/no-explicit-any
    ] as any; // eslint-disable-line @typescript-eslint/no-explicit-any
    vi.mocked(vscode.workspace).workspaceFolders = mockWorkspaceFolders;
    vi.mocked(vscode.window.showWorkspaceFolderPick).mockResolvedValue(
      mockWorkspaceFolders[0] as any // eslint-disable-line @typescript-eslint/no-explicit-any
    );
    vi.mocked(vscode.window.createTerminal).mockReturnValue({
      show: vi.fn(),
      sendText: vi.fn(),
    } as any); // eslint-disable-line @typescript-eslint/no-explicit-any

    await activate(context);

    // Get the registered command for qwen-code.runQwenCode
    const runQwenCodeCommand = vi.mocked(vscode.commands.registerCommand)
      .mock.calls
      .find(call => call[0] === 'qwen-code.runQwenCode')?.[1];

    if (runQwenCodeCommand) {
      await runQwenCodeCommand();
      
      expect(vscode.window.showWorkspaceFolderPick).toHaveBeenCalled();
      expect(vscode.window.createTerminal).toHaveBeenCalledWith({
        name: 'Qwen Code (workspace1)',
        cwd: '/test/workspace1',
      });
    }
  });

  it('should show notices file', async () => {
    const mockUri = {
      toString: () => 'file:///path/to/extension/NOTICES.txt',
      fsPath: '/path/to/extension/NOTICES.txt',
    };
    vi.mocked(vscode.Uri.joinPath).mockReturnValue(mockUri as any); // eslint-disable-line @typescript-eslint/no-explicit-any
    vi.mocked(vscode.window.showTextDocument).mockResolvedValue({} as any); // eslint-disable-line @typescript-eslint/no-explicit-any

    await activate(context);

    // Get the registered command for qwen-code.showNotices
    const showNoticesCommand = vi.mocked(vscode.commands.registerCommand)
      .mock.calls
      .find(call => call[0] === 'qwen-code.showNotices')?.[1];

    if (showNoticesCommand) {
      await showNoticesCommand();
      
      expect(vscode.Uri.joinPath).toHaveBeenCalledWith(
        context.extensionUri,
        'NOTICES.txt'
      );
      expect(vscode.window.showTextDocument).toHaveBeenCalledWith(mockUri);
    }
  });
});

// Since we cannot easily mock the module-level ideServer variable,
// we will test the deactivate function by verifying its behavior
// with mocks in the environment
describe('deactivate', () => {
  beforeEach(() => {
    // Reset the module to clear any previous state
    vi.resetModules();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should handle deactivate without errors', async () => {
    // Just test that deactivate doesn't crash when ideServer is undefined
    const { deactivate } = await import('./extension.js');
    await deactivate(); // Should not throw
  });
});